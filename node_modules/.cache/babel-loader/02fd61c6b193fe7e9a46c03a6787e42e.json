{"ast":null,"code":"import _slicedToArray from\"/Users/dan/Documents/Development/ReactNodeTest/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useEffect,useState}from'react';var useObserver=function useObserver(targetRef){var _useState=useState(false),_useState2=_slicedToArray(_useState,2),isVisible=_useState2[0],setIsVisible=_useState2[1];useEffect(function(){var observer=new IntersectionObserver(function(entries,observer){entries.forEach(function(entry){if(entry.isIntersecting){if(!isVisible){setIsVisible(true);}observer.unobserve(entry.target);}else{setIsVisible(false);}});});var current=targetRef.current;observer.observe(current);return function(){observer.unobserve(current);};},[isVisible,targetRef]);return[isVisible];};export default useObserver;","map":{"version":3,"sources":["/Users/dan/Documents/Development/ReactNodeTest/src/custom-hooks/observer.js"],"names":["useEffect","useState","useObserver","targetRef","isVisible","setIsVisible","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","unobserve","target","current","observe"],"mappings":"iIAAA,OAASA,SAAT,CAAoBC,QAApB,KAAoC,OAApC,CAEA,GAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAACC,SAAD,CAAe,eACCF,QAAQ,CAAC,KAAD,CADT,wCAC1BG,SAD0B,eACfC,YADe,eAGjCL,SAAS,CAAC,UAAM,CACd,GAAMM,CAAAA,QAAQ,CAAG,GAAIC,CAAAA,oBAAJ,CAAyB,SAACC,OAAD,CAAUF,QAAV,CAAuB,CAC/DE,OAAO,CAACC,OAAR,CAAgB,SAACC,KAAD,CAAW,CACzB,GAAIA,KAAK,CAACC,cAAV,CAA0B,CACxB,GAAI,CAACP,SAAL,CAAgB,CACdC,YAAY,CAAC,IAAD,CAAZ,CACD,CACDC,QAAQ,CAACM,SAAT,CAAmBF,KAAK,CAACG,MAAzB,EACD,CALD,IAKO,CACLR,YAAY,CAAC,KAAD,CAAZ,CACD,CACF,CATD,EAUD,CAXgB,CAAjB,CAaA,GAAMS,CAAAA,OAAO,CAAGX,SAAS,CAACW,OAA1B,CACAR,QAAQ,CAACS,OAAT,CAAiBD,OAAjB,EAEA,MAAO,WAAM,CACXR,QAAQ,CAACM,SAAT,CAAmBE,OAAnB,EACD,CAFD,CAGD,CApBQ,CAoBN,CAACV,SAAD,CAAYD,SAAZ,CApBM,CAAT,CAsBA,MAAO,CAACC,SAAD,CAAP,CACD,CA1BD,CA4BA,cAAeF,CAAAA,WAAf","sourcesContent":["import { useEffect, useState } from 'react';\n\nconst useObserver = (targetRef) => {\n  const [isVisible, setIsVisible] = useState(false);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver((entries, observer) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          if (!isVisible) {\n            setIsVisible(true);\n          }\n          observer.unobserve(entry.target);\n        } else {\n          setIsVisible(false);\n        }\n      });\n    });\n\n    const current = targetRef.current;\n    observer.observe(current);\n\n    return () => {\n      observer.unobserve(current);\n    };\n  }, [isVisible, targetRef]);\n\n  return [isVisible];\n};\n\nexport default useObserver;\n"]},"metadata":{},"sourceType":"module"}